---
layout: post
title:  "深入Activity"
date:   2014-07-23 22:34:24
categories: Android
---

* content
{:toc}

##生命周期
单个Activity的生命周期如下图所示(来自Android Developers文档)：

![单个Activity的生命周](http://7xk2i5.com1.z0.glb.clouddn.com/acti.png)

具体实现过程可以创建一个工程，用Log来查看。

而有多个Activity时，需现在ManiFest文件中添加新的Activity。  
多个Activity，其生命周期是：

![多个Activity的生命周](http://7xk2i5.com1.z0.glb.clouddn.com/QQ截图20150701213512.png)

可以看出，执行新Activity时，原先Activity先执行onPause方法，待新Activity可显示状态创建完成后，再执行onStop方法。

可见Google在设计Activity类时，考虑到切换Activity先使原先Activity不干扰新Activity，因此执行onPause方法。而onStop方法在新Activity创建完成之后在执行，是考虑了安全保护机制，防止新Activity奔溃而原先Activity处于在onStop的不可见状态。

**Activity横竖屏切换时特殊情况**  
 这个生命周期跟清单文件里的配置有关系  
1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，默认首先销毁当前activity,然后重新加载  
>通常此情况需要设置savedInstanceState来保存Activity中的信息，以便重新加载时调用
 
2、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
 
>游戏开发中, 屏幕的朝向都是写死的.

---

##Activity启动模式
>启动模式一共有四种，分别是 standard、singleTop、
singleTask 和 singleInstance，可 以 在 AndroidManifest.xml 中 通 过 给 <activity> 标 签 指 定
android:launchMode 属性来选择启动模式。  

Activity中的任务是与用户交互的一组Activity的集合，Activity会被按打开顺序安排在一个堆栈里。  
任务栈：并不是Activity是Activity的引用（内存地址） 

**standard 标准模式**  
每次激活Activity时都会创建Activity，并放入任务栈中  
默认模式  

**singleTop 独享堆栈顶端**  
如果在任务的栈顶正好存在该Activity的实例，就重用该实例，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)    

**singleTask 独享任务堆栈**  
如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中

**singleInstance单例**  
在一个新栈中创建该Activity实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity的实例存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中


Singletop：如果重复使用上一次的Activity，就重用。
  
singleTask：如果使用已经实例化Activity，就重用，并且删除重用Activity前面的Activity，重用的Activity置顶任务栈。 
 
singleInstance：在一个新栈中创建该Activity实例，并让多个应用共享该栈中的该Activity实例。（调用Activity和重用Activity不在一个栈中）  

singleTop 、singleTask 、singleInstance 优化性能、重用Activity。
